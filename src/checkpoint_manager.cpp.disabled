#include "practice_fixes.hpp"
#include <Geode/modify/GJBaseGameLayer.hpp>
#include <Geode/modify/CheckpointObject.hpp>
#include <Geode/modify/PlayLayer.hpp>

#ifdef GEODE_IS_WINDOWS
const int seedAddr = 0x6a4e20;
#endif

static void resetVariables() {
    auto* mgr = ToastyReplay::get();

    mgr->ignoreFrame = -1;
    mgr->ignoreJumpButton = -1;

    mgr->delayedFrameReleaseMain[0] = -1;
    mgr->delayedFrameReleaseMain[1] = -1;

    mgr->delayedFrameInput[0] = -1;
    mgr->delayedFrameInput[1] = -1;

    mgr->addSideHoldingMembers[0] = false;
    mgr->addSideHoldingMembers[1] = false;
    for (int x = 0; x < 2; x++) {
        for (int y = 0; y < 2; y++)
            mgr->delayedFrameRelease[x][y] = -1;
    }
}

class $modify(CheckpointObject) {
  #ifdef GEODE_IS_WINDOWS
  bool init() {
    bool ret = CheckpointObject::init();
    CheckpointObject* cp = this;
  #else
  static CheckpointObject* create() {
    CheckpointObject* ret = CheckpointObject::create();
    CheckpointObject* cp = ret;
  #endif

    if (!cp) return ret;

    auto* mgr = ToastyReplay::get();
    PlayLayer* pl = PlayLayer::get();

    if (!pl || !pl->m_player1 || !pl->m_player2 || !mgr->currentReplay)
        return ret;

    PlayerStateData p1Data = PlayerPracticeFixes::saveData(pl->m_player1);
    PlayerStateData p2Data = PlayerPracticeFixes::saveData(pl->m_player2);

    int currentFrame = pl->m_gameState.m_currentProgress;

    mgr->checkpoints[cp] = {
      currentFrame,
      p1Data,
      p2Data,
      #ifdef GEODE_IS_WINDOWS
      *(uintptr_t*)((char*)geode::base::get() + seedAddr),
      #else
      0,
      #endif
      mgr->previousFrame
    };

    return ret;
  }
};

class $modify(ToastyReplayPLHook, PlayLayer) {

  void loadFromCheckpoint(CheckpointObject* cp) {

    if (!cp) return PlayLayer::loadFromCheckpoint(cp);

    auto* mgr = ToastyReplay::get();

    if (mgr->state == PLAYBACK) {
      PlayLayer::loadFromCheckpoint(cp);

      if (!mgr->checkpoints.contains(cp)) return;
      if (mgr->checkpoints[cp].frame <= 1) return;

      PlayerStateData p1Data = mgr->checkpoints[cp].p1;
      PlayerStateData p2Data = mgr->checkpoints[cp].p2;

      mgr->respawnFrame = mgr->checkpoints[cp].frame;
      mgr->previousFrame = mgr->checkpoints[cp].previousFrame;
      PlayerPracticeFixes::applyData(this->m_player1, p1Data, false);
      PlayerPracticeFixes::applyData(this->m_player2, p2Data, true);

      return;
    }

    if (mgr->state != RECORD && !mgr->inputFixes)
      return PlayLayer::loadFromCheckpoint(cp);

    if (!mgr->checkpoints.contains(cp)) return PlayLayer::loadFromCheckpoint(cp);

    resetVariables();

    int frame = mgr->checkpoints[cp].frame;
    PlayerStateData p1Data = mgr->checkpoints[cp].p1;
    PlayerStateData p2Data = mgr->checkpoints[cp].p2;

    mgr->ignoreJumpButton = frame + 1;
    mgr->previousFrame = mgr->checkpoints[cp].previousFrame;

    #ifdef GEODE_IS_WINDOWS

    if (mgr->seedEnabled) {
      uintptr_t seed = mgr->checkpoints[cp].seed;
      *(uintptr_t*)((char*)geode::base::get() + seedAddr) = seed;
    }

    #endif

    if (mgr->state == RECORD && mgr->currentReplay)
      InputPracticeFixes::applyFixes(this, p1Data, p2Data, frame);

    PlayLayer::loadFromCheckpoint(cp);

    PlayerPracticeFixes::applyData(this->m_player1, p1Data, false);
    PlayerPracticeFixes::applyData(this->m_player2, p2Data, true);

    if (mgr->state != RECORD && mgr->inputFixes) {
      this->m_player1->releaseButton(static_cast<PlayerButton>(1));
      this->m_player2->releaseButton(static_cast<PlayerButton>(1));
    }
  }

};
